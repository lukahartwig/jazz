import { CodeGroup } from "@/components/forMdx";
export const metadata = { title: "Groups and Ownership" };

# Groups and Ownership

In Jazz, ownership and access controls are managed through a lightweight yet powerful system: Groups. After setting up [authentication](/docs/building-with-jazz/authentication), you'll need to understand how to control who can access and modify your data.

## The Concept of Ownership

Ownership is a fundamental aspect of data in Jazz. Every CoValue must have an owner, which can be:

- An individual **Account** - making the data private to that user
- A **Group** - enabling access for multiple users according to their roles

When you create a new CoValue, you can specify its owner (by default, the current user's account):

<CodeGroup>
```tsx twoslash
import { Group, Account, CoMap, co } from "jazz-tools";

class Note extends CoMap {
  title = co.string;
  content = co.string;
}

// ---cut---
// Create data owned by an individual account
const privateNote = Note.create({ 
  title: "My Private Note",
  content: "Only I can see this"
});

// Create data owned by a group (for sharing)
const group = Group.create();
const sharedNote = Note.create(
  { 
    title: "Team Note",
    content: "The whole team can see this"
  },
  group // This note is owned by the group
);
```
</CodeGroup>

When data is owned by a Group, changes can be synchronized between all Group members across their devices.

## Understanding Groups in Jazz

Groups in Jazz are lightweight, flexible entities that manage permissions and enable collaboration. They provide a simple yet powerful way to:

- Define who can access a particular CoValue
- Specify what actions each user can perform (read, write, admin)
- Enable sharing and collaboration between users
- Create permission hierarchies for complex sharing scenarios

Think of Groups as lightweight permission containers that determine who can access what and with what level of privileges. Since they're so lightweight, you can create as many Groups as you need without worrying about performance or complexity.

## Group Roles

Jazz provides several standard roles that define what actions users can take:

- **Reader**: Can view content but cannot modify it
- **Writer**: Can both view and modify content
- **Admin**: Can view, modify, and manage permissions (add/remove users)

These roles create a clear hierarchy of permissions that makes it easy to control access to your application's data.

See [Groups as Permission Scopes](/docs/groups/intro) for more information.

## How Groups Enable Collaboration

Groups are the foundation of collaboration in Jazz applications. They enable:

1. **Team Workspaces**: Create shared spaces where multiple users can work together
2. **Public Content**: Make content accessible to anyone
3. **Selective Sharing**: Give different levels of access to different users
4. **Permission Hierarchies**: Create organizational structures with inherited permissions

Without Groups, each piece of data would be accessible only to its creator. Groups transform Jazz from a personal data store into a **collaborative platform**.

## Group Sharing Methods

Jazz offers several ways to share content through Groups:

- [**Add Members by ID**](/docs/groups/intro#adding-group-members-by-id): Add specific accounts to a group with defined roles
- [**Public Sharing**](/docs/react/groups/sharing#public-sharing): Make content accessible to everyone using the special "everyone" member
- [**Invite Links**](/docs/react/groups/sharing#invite-links): Generate shareable links for easy collaboration with new users

## Accessing Shared Data

Once data is shared through Groups, accessing it follows the same pattern as any other data in Jazz. The permission system ensures users can only access what they're allowed to see.

Here's an example of accessing data that might be shared with you:

<CodeGroup>
```tsx twoslash
// @filename: schema.ts
import { co, CoMap } from "jazz-tools";

export class Document extends CoMap {
  title = co.string;
  content = co.string;
}
// @filename: SharedDocumentView.tsx
import * as React from "react";
import { useCoState } from "jazz-react";
import { Document } from "./schema";
import { ID } from "jazz-tools";
// ---cut---
function SharedDocumentView({ documentId }: { documentId: ID<Document> }) {
  // Access a shared document by its ID
  const document = useCoState(Document, documentId);
  
  // If it's loading, document will be undefined
  if (document === undefined) {
    return <div>Loading document...</div>;
  }
  
  // If you don't have permission, document will be null
  if (document === null) {
    return <div>Access denied or document not found</div>;
  }
  
  return (
    <div>
      <h1>{document.title}</h1>
      <div>{document.content}</div>
    </div>
  );
}
```
</CodeGroup>

Behind the scenes, Jazz:

1. Returns `undefined` while data is loading
2. Returns `null` if you don't have permission to access the document or it doesn't exist
3. Returns the actual data object once loaded if you have access
4. Establishes a subscription to keep the UI in sync with changes
5. Respects the permission level (reader, writer, admin) when you attempt modifications

This seamless integration of permissions and data access means you don't need to write special code to handle shared content - it just works as long as the permission system is set up correctly.

For detailed information on data access, see the [Subscription and Loading](/docs/react/using-covalues/subscription-and-loading) documentation.

## Group Inheritance

One of the most powerful features of Groups is inheritance. A Group can extend another Group, inheriting its members and their permissions:

<CodeGroup>
```tsx twoslash
import { Group } from "jazz-tools";

// ---cut---
// Company-wide group
const companyGroup = Group.create();

// Team-specific group that inherits company permissions
const teamGroup = Group.create();
teamGroup.extend(companyGroup);

// Project-specific group that inherits team permissions
const projectGroup = Group.create();
projectGroup.extend(teamGroup);
```
</CodeGroup>

This inheritance creates a hierarchy that reflects real-world organizational structures:

- Changes to parent groups automatically propagate to child groups
- Users can have different roles at different levels of the hierarchy
- Removing a user from a parent group automatically removes them from all child groups

See [Group Inheritance](/docs/groups/inheritance) for more information.

## Next Steps

Now that you understand groups and permissions, you're ready to learn about [Sync](/docs/building-with-jazz/sync) - how data changes are propagated between users and devices.

## Further Reading

For more detailed information about groups, see:
- [Groups as Permission Scopes](/docs/groups/intro) - Detailed explanation of group permissions
- [Public Sharing and Invites](/docs/groups/sharing) - Implementation details for sharing
- [Group Inheritance](/docs/groups/inheritance) - Advanced group hierarchies
- [Subscription and Loading](/docs/react/using-covalues/subscription-and-loading) - How to access and load shared data
