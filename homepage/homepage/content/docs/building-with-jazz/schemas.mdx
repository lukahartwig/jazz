import { CodeGroup } from "@/components/forMdx";
export const metadata = { title: "Schemas" };

# Schemas

Schemas define the structure of your data in Jazz applications, enabling type-safe collaborative editing.

Now that you've [installed Jazz](/docs/building-with-jazz/installation), let's create your first schemas! We'll explore how schemas work with [CoValues](/docs/schemas/covalues), enable [real-time collaboration](/docs/using-covalues/collaboration), and help you build amazing collaborative experiences.

## What are Jazz Schemas?

Think of schemas as blueprints for your data. They tell Jazz what your data looks like and how it behaves when people collaborate.

In Jazz, we use special data structures called **CoValues** (Collaborative Values). Think of CoValues as **super-fast Git for lots of tiny data** - they track changes, handle merges, and keep everything in sync, but for small pieces of data rather than entire files.

With CoValues, you get:

- Automatic change tracking without any extra code
- Conflict resolution when two people edit the same thing
- TypeScript types that stay accurate as your data changes

### Why Zod for Schemas?

We chose [Zod](https://zod.dev/) to handle our schema validation because it makes your life easier:

- **Simple to Use**: Zod's straightforward syntax means you'll be writing schemas in minutes, not hours
- **Catches Bugs Early**: It validates your data at runtime with helpful error messages that point directly to the problem
- **TypeScript Heaven**: Zod automatically generates TypeScript types so you don't have to write them twice
- **Works Great with AI Tools**: The clean syntax plays nicely with AI assistants and language models
- **Grows With You**: As your app gets bigger, Zod's modular approach makes it easy to evolve your schemas

By combining Zod with our collaborative data structures, we've created a system that's powerful yet feels natural to use.

### Built on CRDTs

Behind the scenes, CoValues use Conflict-free Replicated Data Types (CRDTs). Don't worry about the fancy name - it just means your data works well in a collaborative environment without constant server check-ins.

We built Jazz on CRDTs because they allow for true local-first collaboration. Your app works even when offline, and when everyone reconnects, all the changes merge together smoothly.

Here's what that means for you:

- **No more merge conflicts**: When two people change the same thing, the system figures it out automatically
- **Works offline**: Make changes on the plane, in a tunnel, or anywhere - they'll sync when you reconnect
- **No server required**: Your users can collaborate directly without everything going through a central server
- **Everything eventually matches**: Everyone ends up seeing the same data, even if changes arrive in a different order

The best part? You don't need to worry about any of this complexity. We handle it behind the scenes so you can focus on building your app.

## Why Use Schemas?

Defining schemas early in your project saves you tons of headaches down the road:

1. **Catch Errors Early**: TypeScript will warn you about mistakes as you type, not when your app crashes in production
2. **Self-Documenting Code**: Your schemas clearly show everyone on your team what your data looks like
3. **Easy Updates**: When your app evolves, schemas make it simple to modify your data model without breaking things
4. **Collaboration Built-in**: Everyone works with the same data model, so collaboration just works

## Anatomy of a Schema

Creating schemas in Jazz is surprisingly simple. We use [Zod](https://zod.dev/) for validation and add our own special sauce with the `co` namespace to make things collaborative.

Here's a basic example:

<CodeGroup>
```ts twoslash
import { co, z } from "jazz-tools";

// Define a list of tasks 
export const TaskList = co.list(z.string());

// Define a project
export const Project = co.map({
  // Simple field
  title: z.string(),
  
  // Reference to another CoValue
  tasks: TaskList,
});
```
</CodeGroup>

This example shows several cool things about Jazz schemas:

- **Super readable**: The syntax is clean and easy to understand
- **Field declarations**: We use `co` combined with Zod to define fields
- **Connected data**: Schemas can easily reference other schemas
- **Type-safe**: TypeScript automatically figures out the right types

## CoValue Types

Jazz gives you a few different types of collaborative values to model your data. Here are the two you'll use most often:

<CodeGroup>
```ts twoslash
import { co, z } from "jazz-tools";

// co.map - for object-like data with named properties
export const Task = co.map({
  description: z.string(),
  completed: z.boolean(),
  dueDate: z.date(),
});

// CoList - for ordered collections of items
export const TaskList = co.list(Task);
```
</CodeGroup>

Jazz offers several types of CoValues:

- [**CoMap**](/docs/using-covalues/comaps) - For object-like data with named properties (like a JSON object)
- [**CoList**](/docs/using-covalues/colists) - For ordered collections of items (like an array)
- [**CoFeed**](/docs/using-covalues/cofeeds) - Perfect for comments, reactions, or activity streams
- [**FileStream**](/docs/using-covalues/filestreams) - For binary data like images and documents

Check out the [CoValues documentation](/docs/schemas/covalues) to learn more about all these types.

## Field Types

Jazz gives you lots of field types to express exactly what your data should look like. Here's an example showing some of the possibilities:

<CodeGroup>
```ts twoslash
import { co, z, CoListSchema } from "jazz-tools";

// A simple category
export const Category = co.map({
  name: z.string(),
});

// ---cut---
// A product with various field types
export const Product = co.map({
  // Basic types
  name: z.string(),
  price: z.number(),
  inStock: z.boolean(),
  createdAt: z.date(),
  
  // Enum/literal type
  status: z.literal(["draft", "published", "archived"]),
  
  // Optional field
  description: z.optional(z.string()),
  
  // References to other CoValues
  category: Category,
  get relatedProducts(): z.ZodOptional<CoListSchema<typeof Product>> {
    return z.optional(co.list(Product));
  }
});
```
</CodeGroup>

Here are the main field types you'll use:

- **Simple types**: `z.string()`, `z.number()`, `z.boolean()`, `z.date()`
- **Choice fields**: `z.literal(["option1", "option2"])` for predefined choices
- **Optional fields**: `z.optional(z.string())` for fields that might not exist
- **References**: Use other schemas directly to link your data together

Want to see all the options? Check out the [Field Types documentation](/docs/schemas/covalues#covalue-fielditem-types).

## Next Steps

Now that you've got schemas under your belt, let's connect them to your application with [Providers](/docs/building-with-jazz/providers).

## Further Reading

Want to dive deeper? Check out these resources:

- [CoValues Reference](/docs/schemas/covalues) - See all the details about CoValue types
- [Field Types](/docs/schemas/covalues#covalue-fielditem-types) - The complete field type reference
- [Accounts & Migrations](/docs/schemas/accounts-and-migrations) - Learn how to evolve your schemas over time
- [Schema Examples](/docs/examples/schema-patterns) - Common patterns to solve real-world problems
- [Type Safety](/docs/schemas/type-safety) - Get the most out of TypeScript with Jazz