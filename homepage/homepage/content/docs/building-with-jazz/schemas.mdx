import { CodeGroup } from "@/components/forMdx";
export const metadata = { title: "Schemas" };

# Schemas

Schemas are the foundation of your Jazz application. They define the structure of your data and enable collaboration between users.

## What are Jazz Schemas?

In Jazz, schemas define the shape of your data using **CoValues** (Collaborative Values). Think of CoValues as special data structures that multiple users can edit simultaneously, with changes syncing automatically across devices.

CoValues are similar to standard data structures like objects and arrays, but with built-in collaboration capabilities:

- They track the complete history of changes
- They resolve conflicts automatically when users make simultaneous edits
- They provide type safety through TypeScript

### Built on CRDTs

CoValues are Conflict-free Replicated Data Types (CRDTs).

Using CRDTs provides important benefits:

- **Automatic conflict resolution**: When two users make simultaneous edits, the system resolves them consistently rather than requiring manual intervention.

- **Offline-first operation**: Users can make changes offline, and those changes will synchronize correctly when they reconnect.

- **Distributed collaboration**: Multiple clients can collaborate without requiring constant server coordination.

- **Eventual consistency**: All users will eventually see the same state, even if changes arrive in different orders.

Jazz simplifies working with CRDTs by handling the complexity behind intuitive APIs, allowing you to focus on building your application logic rather than managing distributed data structures.

## Why Use Schemas?

Defining schemas at the start of your project offers several benefits:

1. **Type Safety**: Catch errors at compile time rather than runtime
2. **Documentation**: Clearly communicate the structure of your application's data
3. **Migrations**: Simplify application updates when your data model evolves
4. **Collaboration**: Enable multiple clients to work with the same data model

## Anatomy of a Schema

At their core, Jazz schemas are just TypeScript classes that extend CoValue types. This class-based approach provides both type checking and runtime validation.

<CodeGroup>
```ts twoslash
import { co, z } from "jazz-tools";

// Define a list of tasks (extends CoList)
export const TaskList = co.list(z.string());

// Define a project (extends CoMap)
export const Project = co.map({
  // Simple field
  title: z.string(),
  
  // Reference to another CoValue
  tasks: TaskList,
});
```
</CodeGroup>

This example shows several key aspects of Jazz schemas:

- **Class inheritance**: Schemas extend base CoValue types like `CoMap` and `CoList`
- **Field declarations**: Fields use the `co` namespace to define their types
- **Schema relationships**: Schemas can reference other schemas with `co.ref`
- **Type inference**: TypeScript understands your schema structure automatically

## CoValue Types

Jazz provides several CoValue types to model different kinds of data. Here's a simple example using the two most common types:

<CodeGroup>
```ts twoslash
import { co, z } from "jazz-tools";

// co.map - for object-like data with named properties
export const Task = co.map({
  description: z.string(),
  completed: z.boolean(),
  dueDate: z.date(),
});

// CoList - for ordered collections of items
export const TaskList = co.list(Task);
```
</CodeGroup>

Jazz offers several types of CoValues:

- [**CoMap**](/docs/using-covalues/comaps) - Object-like data with named properties (JSON objects)
- [**CoList**](/docs/using-covalues/colists) - Ordered collections of items (JSON arrays)
- [**CoFeed**](/docs/using-covalues/cofeeds) - Special collections where each user can add items (great for comments, reactions, etc.)
- [**FileStream**](/docs/using-covalues/filestreams) - Binary data like images and documents

For more information on CoValues, check out the [CoValues](/docs/schemas/covalues) documentation.

## Field Types

Jazz provides a range of field types through the `co` namespace. Here's an example showing various field types and relationships:

<CodeGroup>
```ts twoslash
import { co, z, CoListSchema } from "jazz-tools";

// A simple category
export const Category = co.map({
  name: z.string(),
});

// ---cut---
// A product with various field types
export const Product = co.map({
  // Basic types
  name: z.string(),
  price: z.number(),
  inStock: z.boolean(),
  createdAt: z.date(),
  
  // Enum/literal type
  status: z.literal(["draft", "published", "archived"]),
  
  // Optional field
  description: z.optional(z.string()),
  
  // References to other CoValues
  category: Category,
  get relatedProducts(): z.ZodOptional<CoListSchema<typeof Product>> {
    return z.optional(co.list(Product));
  }
});
```
</CodeGroup>

The main field types include:

- **Primitive types**: `co.string`, `co.number`, `co.boolean`, `co.Date`
- **Literal values**: `co.literal("value1", "value2")` for enums
- **Optional fields**: `co.optional.string`, `co.optional.number`, etc.
- **References**: `co.ref(SomeCoValue)` to link to other CoValues

For more information on field types, check out the [Field Types](/docs/schemas/covalues#covalue-fielditem-types) documentation.

## Next Steps

Now that you understand schemas, the next step is to connect them to your application using [Providers](/docs/building-with-jazz/providers). Providers handle the connection to Jazz's sync network and make your data available to your UI components.

## Further Reading

- [Schemas](/docs/schemas/covalues)